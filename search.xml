<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>VUE入坑指南</title>
      <link href="/2018/10/12/VUE%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>/2018/10/12/VUE%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="先安装node-js，"><a href="#先安装node-js，" class="headerlink" title="先安装node.js，"></a>先安装node.js，</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nodejs</span><br></pre></td></tr></table></figure><p>然后npm替换成淘宝的镜像站 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>这样以后就能使用cnpm命令安安装包了 </p><h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><p>webpack 是个前端打包工具，详情google </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></table></figure><p>-g是全局的意思</p><h3 id="安装vue脚手架vue-cli"><a href="#安装vue脚手架vue-cli" class="headerlink" title="安装vue脚手架vue-cli"></a>安装vue脚手架vue-cli</h3><p>vue-cli是vue官方发布的一个快速搭建项目的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><h2 id="创建示例项目"><a href="#创建示例项目" class="headerlink" title="创建示例项目"></a>创建示例项目</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>先创建project workspace， 如果不创建也没关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir VueProject</span><br><span class="line">cd VueProject </span><br><span class="line">vue init webpack-simple 工程名字（不能使用中文）</span><br></pre></td></tr></table></figure><p>操作如下图：</p><p><img src="/images/image1.png" alt=""></p><p>然后根据提示去操作，这个地方如果使用的是 cnpm命令的话，两个指令要同时都适用cnpm否则会缺少包 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd test </span><br><span class="line"></span><br><span class="line">npm install </span><br><span class="line"></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>其实上面的npm run dev就是启动项目的 </p><p><img src="/images/image2.png" alt=""></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>npm run dev在启动项目之后，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 的时候发现是一片空白 </p><p>用浏览器调试显示如下：</p><p><img src="/images/image3.png" alt=""></p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;#eval-source-map’ </span><br><span class="line"></span><br><span class="line">改成</span><br><span class="line"></span><br><span class="line">devtool: &apos;inline-source-map’</span><br></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></p><p><a href="https://webpack.docschina.org/configuration/devtool/" target="_blank" rel="noopener">https://webpack.docschina.org/configuration/devtool/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法导论-插入排序（Insertion Sort）</title>
      <link href="/2018/10/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89/"/>
      <url>/2018/10/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>输入</strong> ：n个数的一个序列(a1, a2, … , an)</p><p><strong>输出</strong>：输入序列的一个排序(a’1, a’2, … , a’n)，满足 a’1 &lt;= a’2 &lt;= … &lt;= a’n</p><h2 id="插入排序算法描述"><a href="#插入排序算法描述" class="headerlink" title="插入排序算法描述"></a>插入排序算法描述</h2><p>插入排序的工作原理是：<span class="high-light-font"> 通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入</span>。</p><p>在生活中，最直观插入排序的例子是，整理纸牌。人们在整理纸牌的方法是一张一张的来，通过对比手上已经排好顺序的排列，插入到适合的位置。</p><p>插入排序在实现上也是一种<span class="high-light-font">in-place排序列</span>（这种排序概念请查看相应的文章），就是原地排序。所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。</p><h2 id="Java实现代码"><a href="#Java实现代码" class="headerlink" title="Java实现代码"></a><strong>Java</strong>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liusxg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">*<span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by liusxg on 2018/10/8.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 插入排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 工作原理是通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ** 插入排序在实现上也是一种in-place*排序（这种排序概念请查看相应的文章），就是原地排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">            Integer key = list.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从后往前扫描，并且如果还没找到合适的位置，需要将已经排序的元素往后逐步挪动，给新的元素让出插入空间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; list.get(j) &gt; key; j--) &#123; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">                list.set(j + <span class="number">1</span>, list.get(j));</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"compare to [0, "</span> + j + <span class="string">"] : "</span> + list);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.set(j + <span class="number">1</span>, key);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"current list : "</span> + list);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; testArr = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; testArr = Arrays.asList(3, 1);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"before sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">        InsertionSort.sort(testArr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"after sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>根据 <a href="https://liusxg.github.io/2018/10/10/算法导论-算法分析/">算法分析</a> 所描述的，当插入排序的输入序列是正序的时候，插入排序的算法运行时间是是一个n的线性函数，即算法复杂度为<span class="high-light-font">⍬(n)</span>；当输入序列是倒序的时候，算法运行时间是n的二次函数，即算法复杂度为 <span class="high-light-font"> ⍬(n^2)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法导论-算法分析</title>
      <link href="/2018/10/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2018/10/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么样衡量一个算法的性能？"><a href="#怎么样衡量一个算法的性能？" class="headerlink" title="怎么样衡量一个算法的性能？"></a>怎么样衡量一个算法的性能？</h2><p>​    分析一个算法，其实意味着要去预测这个算法需要的资源。虽然我们有时主要关心内存，通信带宽或者计算机硬件这类资源，但是我们通常最关心的是该算法的计算时间。可以说一个算法的计算时间是衡量一个算法是否优质的最重要的一个指标。执行越快的算法我们可以称之为越有效。算法分析主要针对是多个算法进行对比，对于单个算法毫无意义。这个执行时间通常被称为<span class="high-light-font">时间复杂度</span>。通过分析对比多个算法的时间复杂度，我们可以选择出最有效的算法，同时在这个分析的前提是这个算法是正确的，经得起循环不变式检验的。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>通过分析插入排序算法，我们来理解怎么进行一个算法分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by liusxg on 2018/10/8.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 插入排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 工作原理是通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ** 插入排序在实现上也是一种in-place*排序（这种排序概念请查看相应的文章），就是原地排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">            Integer key = list.get(i); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//从后往前扫描，并且如果还没找到合适的位置，需要将已经排序的元素往后逐步挪动，给新的元素让出插入空间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; list.get(j) &gt; key; j--) &#123; <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">                list.set(j + <span class="number">1</span>, list.get(j)); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"compare to [0, "</span> + j + <span class="string">"] : "</span> + list); </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.set(j + <span class="number">1</span>, key); <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"current list : "</span> + list); </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; testArr = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"before sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">        InsertionSort.sort(testArr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"after sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先贴出插入排序的代码；</p><p>因为不知道不同计算机影响对单句代码执行优化的程度，而且不同的语句执行的时间也不一定一样，但是相同的一行代码重复执行基本上是一个常量时间。以上插入排序的代码一共有6行，我们暂定<span class="high-light-font">c1~c6</span>分别代表着6行代码各自的执行时间。</p><p>假设需要排序的序列长度是n，即<span class="high-light-font">n=list.size()</span>，我们可以得到每一行代码执行的总时间，即<span class="high-light-font">各自的执行次数*执行时间</span>；</p><p>第一行根据循环次数，会执行n-1次，总执行时间是 t1=c1*(n-1)<br>然后就是<br>t2=c2*(n-1)<br>t3=c3*(n-1)<br>t4看情况，如果序列已经是正序了那就是 c4*(n-1) ，如果是倒序，则是 c4*(1+2+…+n-1)=(1/2)*c4<em>n\</em>(n-1)<br>t5在t4的作用域里，如果序列已经是正序了那就是 0，如果是倒序，则是 c5*(1+2+…+n-1)=(1/2)*c5<em>n\</em>(n-1)<br>这时候就可以计算出算法的最优时间和最坏时间</p><p>总执行时间：<br>T=t1+t2+t3+t4+t5+t6</p><h3 id="最优时间"><a href="#最优时间" class="headerlink" title="最优时间"></a>最优时间</h3><p>T优=(c1+c2+c3+c4+c5+c6)*(n-1)=(c1+c2+c3+c4+c5+c6)*n - (c1+c2+c3+c4+c5+c6)</p><h3 id="最坏时间"><a href="#最坏时间" class="headerlink" title="最坏时间"></a>最坏时间</h3><p>T坏=(c4/2+c5/2)*n*(n-1) + (c1+c2+c3+c6)*(n-1)</p><p>化简：<br>T坏=(c4/2+c5/2)*n^2 + (c1+c2+c3+c6-c4/2-c5/2)*n -  (c1+c2+c3+c6)<br>最优时间是一个n的<strong>线性函数</strong>，最坏时间是n的<strong>二次函数</strong>。</p><h2 id="为什么要求一个算法的最坏时间？"><a href="#为什么要求一个算法的最坏时间？" class="headerlink" title="为什么要求一个算法的最坏时间？"></a>为什么要求一个算法的最坏时间？</h2><p>1.最坏时间代表着这个<span class="high-light-font">算法执行时间的上界</span>，意味着不管输入是怎么样的，执行时间都不会超过这个最坏时间；</p><p>2.算法的最坏情况经常会出现，不能寄希望于偶尔会出现最好的情况。</p><p>3.算法的平均情况一般会跟最坏的情况是一致的。</p><p>所以一般来说，算法的最坏情况更能体现一个算法的有效性，更具有参考价值。</p><h2 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h2><p>​    因为上面我们并不知晓某一行代码在不同的计算机硬件具体的执行时间，我们就已经简化假设了单行代码的执行时间为常量，c1~c6，虽然已经简化了，但是明显影响我们对这个算法的分析。插入排序算法最坏时间的结果是(c4/2+c5/2)n^2 + (c1+c2+c3+c6-c4/2-c5/2)n -  (c1+c2+c3+c6)，看起来还是不是很直观。我们还可以继续简化，令a=(c4/2+c5/2), b=(c1+c2+c3+c6-c4/2-c5/2), c=- (c1+c2+c3+c6)，所以得到的是an^2+bn+c，其中a,b,c也是常量。我们注意到这样并不会影响结果，而且更加的直观。</p><p>​    现在我们要更简化上面的式子，其实我们真正感兴趣的是执行时间的<span class="high-light-font">增长率</span>，<span class="high-light-font">增长量级</span>。所以我们比较关注的是a^2这一项，当n足够大的时候，就可以省略低阶，和常系数。忽略了这些之后，留下的只剩下最重要的因子n^2。这时候我们引入一个表达式，<span class="high-light-font">⍬(n^2)</span>，读作theta n^2。这就是很多文章里写的时间复杂度。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    如果一个算法的最差运行时间要比另外一个算法最差运行时间具有更小的增长量级，我们通常认为这个算法比另外一个算法更有效。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
