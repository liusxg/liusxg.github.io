<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java语言程序设计-关键术语</title>
      <link href="/2018/10/17/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD/"/>
      <url>/2018/10/17/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p>为什么要学习Java，Java这门语言有什么特性，有什么优势？根据<a href="https://www.oracle.com/technetwork/java/langenv-140151.html" target="_blank" rel="noopener">白皮书</a>，我大致列举了以下这些特性：</p><p>1.简单性</p><p>2.面向对象</p><p>3.网络技能</p><p>4.健壮性</p><p>5.安全性</p><p>6.体系结构中立</p><p>7.可移植性</p><p>8.解释型</p><p>9.高性能</p><p>10.多线程</p><p>11.动态性</p><p>这些特性其实在初学语言的时候随便看看就好，不用当作关注的重点，也不一定记得住，所以不需要过分关注，不看也罢。相反的，当你对Java语言有一定的理解之后，再回来看这个，你会觉得有点意思，甚至可以加深你对语言能力的认知。下面我们对这些关键术语逐一进行解释。</p><h2 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h2><p>Java基本上是C++的纯净版，没有指针，头文件等，结构等乱七八糟的功能。简单性的一方面是在说这种语言的语法简单，语言程序设计简单，容易上手。还有另外一个方面是小，Java的目标之一就是能开发在小型机器上独立运行的软件。Java的解释器也就40KB，加上一些必要的类库，类加载器，网络，多线程支持等，也大概在210KB左右。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>简单来说，面向对象是一种程序设计方法，相对应的是面向过程设计。与面向过程程序设计不一样的是，面向对象重点在数据和接口。理解了这两个概念对以后的语言的理解有很大的帮助。面向过程在代码形式来说，重点在过程，数据是过程的副产物；面向对象引入对象的概念，把所有事物都封装成一个对象，对象里有属性和方法，属性是数据，方法是操作数据的过程。对于一些比较小规模的问题分解成过程的开发方式比较理想，但是对于规模比较大的问题，面向对象要更适应。比如一个web服务器，使用面向过程来实现大概需要2000个过程，面向对象大概需要100个类，每个类有10个方法。出现问题的时候定位不同对象的数据项明显要比排查2000个过程要容易的多。</p><h2 id="网络技能"><a href="#网络技能" class="headerlink" title="网络技能"></a>网络技能</h2><p>Java有一个拓展的例程库，用于处理HTTP和FTP之类的TCP/IP协议。这个库对针对操作sokect连接这种繁琐的操作进行了封装，使得Java应用程序可以通过URL打开和访问网络上的资源文件，就像访问本地文件一样方便。</p><h2 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h2><p>Java设计的目标之一是使Java编写的程序有多方面的可靠性。表现在下面几个方面：</p><p>1.Java采用的指针模型可以消除重写内存和损坏数据的可能性。</p><p>2.Java投入大量的精力放在早期的问题检测，也就是程序编译阶段。Java的编译器可以检测到很多其他语言在运行时才能检测出来的问题。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>Java适用于网络和分布式环境，要达到这个目的，Java在安全性上做了很大的工作，体现在以下几个方面</p><p>1.防范运行时内存溢出</p><p>2.防范在自己的处理空间之外破坏内存</p><p>3.防范未经授权读写文件</p><p>之后的版本迭代更新也不断加入新的安全技术。</p><h2 id="体系结构中立"><a href="#体系结构中立" class="headerlink" title="体系结构中立"></a>体系结构中立</h2><p>Java使用的是虚拟机技术，也就是编译器会将程序编译成一种跟计算机结构无关的文件格式，我们称之为字节码，当需要程序运行的时候，虚拟机的解释器可以快速的将这些字节码解释成对应的不同机器对应的机器指令执行。这并不是很独创的技术，很多语言都有这种设计。因为字节码需要虚拟机解释成机器指令然后执行，中间多了一步解释的过程，早期的解释器设计会让人产生一种误解，Java运行很慢，比不上c这种全速执行机器指令的程序，但是这已经是老皇历了，现在的Java解释器可以将使用最频繁的字节码序列翻译成机器指令，这叫做<span class="high-light-font">即时编译</span>。所以现在的虚拟机执行字节码的速度比大家印象中的还要快。</p><h2 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h2><p>Java的设计的目标之一是跨平台，所有的不同都是通过虚拟机去实现一些本地方法，对于上层的都是完全一致的，这就对可移植性提供了很大的支持。同时，Java的基础类型都是固定长度，字符是Unicode格式存储的，这就消除了字节存储顺序的问题。</p><h2 id="解释型"><a href="#解释型" class="headerlink" title="解释型"></a>解释型</h2><p>Java是通过解释器来翻译字节码并执行的。</p><h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><p>现在的即时编译器的性能可以跟传统编译器性能一较高下，由于即时编译器包含更多的信息，从这一方面来说，即时编译器已经超越了传统的编译器。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Java虚拟机通过底层方法来调用操作系统或者线程库进行多线程操作，对于开发，Java调用多线程的代码也很方便。</p><h2 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h2><p>Java是一种动态语言，他的动态性体现在程序运行的时候可以动态加载类，同时还提供了反射等一系列特性动态访问对象的方法和属性。</p>]]></content>
      
      
      <categories>
          
          <category> Java语言程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java语言程序设计 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java语言程序设计-预留关键字</title>
      <link href="/2018/10/16/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%A2%84%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/10/16/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E9%A2%84%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>Java一共预留了51个关键字，不同的关键字各自对应的含义如下，在编写代码的过程中，命名不得跟关键字冲突。关键字大概分为7类：访问修饰符，定义或者创建，基础类型，用于调试代码，流程控制，捕获异常，导包。还有两个关键字暂时没有用到。</p><h2 id="访问修饰符，用于方法或者属性上"><a href="#访问修饰符，用于方法或者属性上" class="headerlink" title="访问修饰符，用于方法或者属性上"></a>访问修饰符，用于方法或者属性上</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>：这个特性只有该类方法能访问</span><br><span class="line"><span class="keyword">protected</span>：这个特性只有该类，及其子类以及同一个包中的其他类能访问</span><br><span class="line"><span class="keyword">public</span>：这个特性所有类都能访问</span><br></pre></td></tr></table></figure><h2 id="定义类，方法，接口，属性；继承，实现，创建实例"><a href="#定义类，方法，接口，属性；继承，实现，创建实例" class="headerlink" title="定义类，方法，接口，属性；继承，实现，创建实例"></a>定义类，方法，接口，属性；继承，实现，创建实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span>：抽象类或方法</span><br><span class="line"><span class="class"><span class="keyword">class</span>：定义一个类类型</span></span><br><span class="line"><span class="class"><span class="keyword">extends</span>：继承</span></span><br><span class="line"><span class="class"><span class="title">final</span>：一个常量，不能覆盖的类或者方法，不能派生子类</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span>：实现接口方法</span></span><br><span class="line"><span class="class"><span class="title">interface</span>：定义一个接口类型</span></span><br><span class="line"><span class="class"><span class="title">native</span>：本地方法</span></span><br><span class="line"><span class="class"><span class="title">new</span>：创建一个实例</span></span><br><span class="line"><span class="class"><span class="title">null</span>：一个空引用，技术上来说，这是一个直接量，不是关键字</span></span><br><span class="line"><span class="class"><span class="title">static</span>：修饰的属性或者方法属于类不属于实例</span></span><br><span class="line"><span class="class"><span class="title">strictfp</span>：对浮点运算使用严格的规则</span></span><br><span class="line"><span class="class"><span class="title">super</span>：父类对象的引用或者父类构造方法</span></span><br><span class="line"><span class="class"><span class="title">synchronized</span>：表示方法或者代码块同步执行</span></span><br><span class="line"><span class="class"><span class="title">this</span>：当前实例对象的引用或者构造方法</span></span><br><span class="line"><span class="class"><span class="title">transient</span>：标志非永久数据，声明不用序列话的成员域</span></span><br><span class="line"><span class="class"><span class="title">void</span>：表示一个方法可以没有返回值</span></span><br><span class="line"><span class="class"><span class="title">volatile</span>：确保一个字段能被多个线程访问</span></span><br></pre></td></tr></table></figure><h2 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>：断言，用来查找程序内部错误</span><br></pre></td></tr></table></figure><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>：布尔类型</span><br><span class="line"><span class="keyword">byte</span>：<span class="number">8</span>位整数类型</span><br><span class="line"><span class="keyword">char</span>：Unicode字符类型</span><br><span class="line"><span class="keyword">double</span>：双精度浮点类型</span><br><span class="line"><span class="keyword">enum</span>：枚举类型</span><br><span class="line"><span class="keyword">float</span>：单精度浮点类型</span><br><span class="line"><span class="keyword">int</span>：<span class="number">32</span>位整数类型</span><br><span class="line"><span class="keyword">long</span>：<span class="number">64</span>位整数类型</span><br><span class="line"><span class="keyword">short</span>：<span class="number">16</span>位整数类型</span><br></pre></td></tr></table></figure><h2 id="流程控制，条件判断"><a href="#流程控制，条件判断" class="headerlink" title="流程控制，条件判断"></a>流程控制，条件判断</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span>：中断程序</span><br><span class="line"><span class="keyword">case</span>：<span class="keyword">switch</span>的一个分支</span><br><span class="line"><span class="keyword">continue</span>：回到当前块的开始处</span><br><span class="line"><span class="keyword">default</span>：<span class="keyword">switch</span>的缺省分支</span><br><span class="line"><span class="keyword">do</span>：<span class="keyword">do</span>/<span class="keyword">while</span>最前面的语句</span><br><span class="line"><span class="keyword">if</span>：条件判断语句，后面带判断条件</span><br><span class="line"><span class="keyword">else</span>：条件判断语句，<span class="keyword">if</span>条件的字句</span><br><span class="line"><span class="keyword">for</span>：一种循环结构</span><br><span class="line">instanceOf：判断一个对象是否为某一个类的实例</span><br><span class="line"><span class="keyword">return</span>：方法的返回结果</span><br><span class="line"><span class="keyword">switch</span>：条件判断语句：可以匹配多种结果</span><br><span class="line"><span class="keyword">while</span>：条件判断语句，可以单独使用，也可以跟<span class="keyword">do</span>配合使用</span><br></pre></td></tr></table></figure><h2 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>：捕获异常语句，<span class="keyword">try</span>的子句</span><br><span class="line"><span class="keyword">finally</span>：<span class="keyword">try</span>的字句，表示最后总会执行的代码块</span><br><span class="line"><span class="keyword">throw</span>：抛出一个异常</span><br><span class="line"><span class="keyword">throws</span>：一个方法可能抛出的异常</span><br><span class="line"><span class="keyword">try</span>：捕获异常语句</span><br></pre></td></tr></table></figure><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>：导入一个包或者一个类</span><br><span class="line"><span class="keyword">package</span>：包含类的包</span><br></pre></td></tr></table></figure><h2 id="保留字，预留的关键字，目前Java尚未使用到的关键字"><a href="#保留字，预留的关键字，目前Java尚未使用到的关键字" class="headerlink" title="保留字，预留的关键字，目前Java尚未使用到的关键字"></a>保留字，预留的关键字，目前Java尚未使用到的关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>：未使用</span><br><span class="line">goto：未使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java语言程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java语言程序设计 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VUE入坑指南</title>
      <link href="/2018/10/12/VUE%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/"/>
      <url>/2018/10/12/VUE%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="先安装node-js，"><a href="#先安装node-js，" class="headerlink" title="先安装node.js，"></a>先安装node.js，</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nodejs</span><br></pre></td></tr></table></figure><p>然后npm替换成淘宝的镜像站 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>这样以后就能使用cnpm命令安安装包了 </p><h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><p>webpack 是个前端打包工具，详情google </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install webpack -g</span><br></pre></td></tr></table></figure><p>-g是全局的意思</p><h3 id="安装vue脚手架vue-cli"><a href="#安装vue脚手架vue-cli" class="headerlink" title="安装vue脚手架vue-cli"></a>安装vue脚手架vue-cli</h3><p>vue-cli是vue官方发布的一个快速搭建项目的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-cli -g</span><br></pre></td></tr></table></figure><h2 id="创建示例项目"><a href="#创建示例项目" class="headerlink" title="创建示例项目"></a>创建示例项目</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>先创建project workspace， 如果不创建也没关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir VueProject</span><br><span class="line">cd VueProject </span><br><span class="line">vue init webpack-simple 工程名字（不能使用中文）</span><br></pre></td></tr></table></figure><p>操作如下图：</p><p><img src="/images/image1.png" alt=""></p><p>然后根据提示去操作，这个地方如果使用的是 cnpm命令的话，两个指令要同时都适用cnpm否则会缺少包 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd test </span><br><span class="line"></span><br><span class="line">npm install </span><br><span class="line"></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><p>其实上面的npm run dev就是启动项目的 </p><p><img src="/images/image2.png" alt=""></p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>npm run dev在启动项目之后，访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 的时候发现是一片空白 </p><p>用浏览器调试显示如下：</p><p><img src="/images/image3.png" alt=""></p><p>解决办法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devtool: &apos;#eval-source-map’ </span><br><span class="line"></span><br><span class="line">改成</span><br><span class="line"></span><br><span class="line">devtool: &apos;inline-source-map’</span><br></pre></td></tr></table></figure><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a></p><p><a href="https://webpack.docschina.org/configuration/devtool/" target="_blank" rel="noopener">https://webpack.docschina.org/configuration/devtool/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> VUE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法导论-插入排序（Insertion Sort）</title>
      <link href="/2018/10/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89/"/>
      <url>/2018/10/11/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Insertion%20Sort%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>输入</strong> ：n个数的一个序列(a1, a2, … , an)</p><p><strong>输出</strong>：输入序列的一个排序(a’1, a’2, … , a’n)，满足 a’1 &lt;= a’2 &lt;= … &lt;= a’n</p><h2 id="插入排序算法描述"><a href="#插入排序算法描述" class="headerlink" title="插入排序算法描述"></a>插入排序算法描述</h2><p>插入排序的工作原理是：<span class="high-light-font"> 通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入</span>。</p><p>在生活中，最直观插入排序的例子是，整理纸牌。人们在整理纸牌的方法是一张一张的来，通过对比手上已经排好顺序的排列，插入到适合的位置。</p><p>插入排序在实现上也是一种<span class="high-light-font">in-place排序列</span>（这种排序概念请查看相应的文章），就是原地排序。所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。</p><h2 id="Java实现代码"><a href="#Java实现代码" class="headerlink" title="Java实现代码"></a><strong>Java</strong>实现代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.liusxg.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">*<span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by liusxg on 2018/10/8.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 插入排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 工作原理是通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ** 插入排序在实现上也是一种in-place*排序（这种排序概念请查看相应的文章），就是原地排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">            Integer key = list.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从后往前扫描，并且如果还没找到合适的位置，需要将已经排序的元素往后逐步挪动，给新的元素让出插入空间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; list.get(j) &gt; key; j--) &#123; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">                list.set(j + <span class="number">1</span>, list.get(j));</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"compare to [0, "</span> + j + <span class="string">"] : "</span> + list);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.set(j + <span class="number">1</span>, key);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"current list : "</span> + list);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; testArr = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; testArr = Arrays.asList(3, 1);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"before sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">        InsertionSort.sort(testArr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"after sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>根据 <a href="https://liusxg.github.io/2018/10/10/算法导论-算法分析/">算法分析</a> 所描述的，当插入排序的输入序列是正序的时候，插入排序的算法运行时间是是一个n的线性函数，即算法复杂度为<span class="high-light-font">⍬(n)</span>；当输入序列是倒序的时候，算法运行时间是n的二次函数，即算法复杂度为 <span class="high-light-font"> ⍬(n^2)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法导论-算法分析</title>
      <link href="/2018/10/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/2018/10/10/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="怎么样衡量一个算法的性能？"><a href="#怎么样衡量一个算法的性能？" class="headerlink" title="怎么样衡量一个算法的性能？"></a>怎么样衡量一个算法的性能？</h2><p>​    分析一个算法，其实意味着要去预测这个算法需要的资源。虽然我们有时主要关心内存，通信带宽或者计算机硬件这类资源，但是我们通常最关心的是该算法的计算时间。可以说一个算法的计算时间是衡量一个算法是否优质的最重要的一个指标。执行越快的算法我们可以称之为越有效。算法分析主要针对是多个算法进行对比，对于单个算法毫无意义。这个执行时间通常被称为<span class="high-light-font">时间复杂度</span>。通过分析对比多个算法的时间复杂度，我们可以选择出最有效的算法，同时在这个分析的前提是这个算法是正确的，经得起循环不变式检验的。</p><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>通过分析插入排序算法，我们来理解怎么进行一个算法分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Created by liusxg on 2018/10/8.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 插入排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ***</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 工作原理是通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> ** 插入排序在实现上也是一种in-place*排序（这种排序概念请查看相应的文章），就是原地排序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *** 所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertionSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++) &#123; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">            Integer key = list.get(i); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//从后往前扫描，并且如果还没找到合适的位置，需要将已经排序的元素往后逐步挪动，给新的元素让出插入空间</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; list.get(j) &gt; key; j--) &#123; <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">                list.set(j + <span class="number">1</span>, list.get(j)); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"compare to [0, "</span> + j + <span class="string">"] : "</span> + list); </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.set(j + <span class="number">1</span>, key); <span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"current list : "</span> + list); </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; testArr = Arrays.asList(<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"before sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">        InsertionSort.sort(testArr);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"after sort: "</span> + testArr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先贴出插入排序的代码；</p><p>因为不知道不同计算机影响对单句代码执行优化的程度，而且不同的语句执行的时间也不一定一样，但是相同的一行代码重复执行基本上是一个常量时间。以上插入排序的代码一共有6行，我们暂定<span class="high-light-font">c1~c6</span>分别代表着6行代码各自的执行时间。</p><p>假设需要排序的序列长度是n，即<span class="high-light-font">n=list.size()</span>，我们可以得到每一行代码执行的总时间，即<span class="high-light-font">各自的执行次数*执行时间</span>；</p><p>第一行根据循环次数，会执行n-1次，总执行时间是 t1=c1*(n-1)<br>然后就是<br>t2=c2*(n-1)<br>t3=c3*(n-1)<br>t4看情况，如果序列已经是正序了那就是 c4*(n-1) ，如果是倒序，则是 c4*(1+2+…+n-1)=(1/2)*c4<em>n\</em>(n-1)<br>t5在t4的作用域里，如果序列已经是正序了那就是 0，如果是倒序，则是 c5*(1+2+…+n-1)=(1/2)*c5<em>n\</em>(n-1)<br>这时候就可以计算出算法的最优时间和最坏时间</p><p>总执行时间：<br>T=t1+t2+t3+t4+t5+t6</p><h3 id="最优时间"><a href="#最优时间" class="headerlink" title="最优时间"></a>最优时间</h3><p>T优=(c1+c2+c3+c4+c5+c6)*(n-1)=(c1+c2+c3+c4+c5+c6)*n - (c1+c2+c3+c4+c5+c6)</p><h3 id="最坏时间"><a href="#最坏时间" class="headerlink" title="最坏时间"></a>最坏时间</h3><p>T坏=(c4/2+c5/2)*n*(n-1) + (c1+c2+c3+c6)*(n-1)</p><p>化简：<br>T坏=(c4/2+c5/2)*n^2 + (c1+c2+c3+c6-c4/2-c5/2)*n -  (c1+c2+c3+c6)<br>最优时间是一个n的<strong>线性函数</strong>，最坏时间是n的<strong>二次函数</strong>。</p><h2 id="为什么要求一个算法的最坏时间？"><a href="#为什么要求一个算法的最坏时间？" class="headerlink" title="为什么要求一个算法的最坏时间？"></a>为什么要求一个算法的最坏时间？</h2><p>1.最坏时间代表着这个<span class="high-light-font">算法执行时间的上界</span>，意味着不管输入是怎么样的，执行时间都不会超过这个最坏时间；</p><p>2.算法的最坏情况经常会出现，不能寄希望于偶尔会出现最好的情况。</p><p>3.算法的平均情况一般会跟最坏的情况是一致的。</p><p>所以一般来说，算法的最坏情况更能体现一个算法的有效性，更具有参考价值。</p><h2 id="增长量级"><a href="#增长量级" class="headerlink" title="增长量级"></a>增长量级</h2><p>​    因为上面我们并不知晓某一行代码在不同的计算机硬件具体的执行时间，我们就已经简化假设了单行代码的执行时间为常量，c1~c6，虽然已经简化了，但是明显影响我们对这个算法的分析。插入排序算法最坏时间的结果是(c4/2+c5/2)n^2 + (c1+c2+c3+c6-c4/2-c5/2)n -  (c1+c2+c3+c6)，看起来还是不是很直观。我们还可以继续简化，令a=(c4/2+c5/2), b=(c1+c2+c3+c6-c4/2-c5/2), c=- (c1+c2+c3+c6)，所以得到的是an^2+bn+c，其中a,b,c也是常量。我们注意到这样并不会影响结果，而且更加的直观。</p><p>​    现在我们要更简化上面的式子，其实我们真正感兴趣的是执行时间的<span class="high-light-font">增长率</span>，<span class="high-light-font">增长量级</span>。所以我们比较关注的是a^2这一项，当n足够大的时候，就可以省略低阶，和常系数。忽略了这些之后，留下的只剩下最重要的因子n^2。这时候我们引入一个表达式，<span class="high-light-font">⍬(n^2)</span>，读作theta n^2。这就是很多文章里写的时间复杂度。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>​    如果一个算法的最差运行时间要比另外一个算法最差运行时间具有更小的增长量级，我们通常认为这个算法比另外一个算法更有效。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
