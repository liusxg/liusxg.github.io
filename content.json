{"meta":{"title":"Liusxg","subtitle":null,"description":null,"author":"Liusxg","url":"https://liusxg.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-04-09T13:40:47.682Z","updated":"2019-04-09T13:40:47.682Z","comments":false,"path":"/404.html","permalink":"https://liusxg.github.io//404.html","excerpt":"","text":""},{"title":"","date":"2019-04-09T13:56:17.752Z","updated":"2019-04-09T13:56:17.750Z","comments":false,"path":"about/index.html","permalink":"https://liusxg.github.io/about/index.html","excerpt":"","text":"About MeProfession主业Java开发工程师，副业各种捣鼓工程师。 ContactEmail: liusxg@163.com Twitter: liusxg"},{"title":"书单","date":"2019-04-09T13:41:01.724Z","updated":"2019-04-09T13:41:01.724Z","comments":false,"path":"books/index.html","permalink":"https://liusxg.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-04-09T13:41:13.636Z","updated":"2019-04-09T13:41:13.636Z","comments":false,"path":"categories/index.html","permalink":"https://liusxg.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-04-09T13:41:21.663Z","updated":"2019-04-09T13:41:21.663Z","comments":true,"path":"links/index.html","permalink":"https://liusxg.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-09T13:41:30.900Z","updated":"2019-04-09T13:41:30.899Z","comments":false,"path":"repository/index.html","permalink":"https://liusxg.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-04-09T13:41:38.716Z","updated":"2019-04-09T13:41:38.716Z","comments":false,"path":"tags/index.html","permalink":"https://liusxg.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java语言程序设计-关键术语","slug":"Java语言程序设计-关键术语","date":"2018-10-17T09:13:27.000Z","updated":"2018-10-17T09:58:10.124Z","comments":true,"path":"2018/10/17/Java语言程序设计-关键术语/","link":"","permalink":"https://liusxg.github.io/2018/10/17/Java语言程序设计-关键术语/","excerpt":"","text":"为什么要学习Java，Java这门语言有什么特性，有什么优势？根据白皮书，我大致列举了以下这些特性： 1.简单性 2.面向对象 3.网络技能 4.健壮性 5.安全性 6.体系结构中立 7.可移植性 8.解释型 9.高性能 10.多线程 11.动态性 这些特性其实在初学语言的时候随便看看就好，不用当作关注的重点，也不一定记得住，所以不需要过分关注，不看也罢。相反的，当你对Java语言有一定的理解之后，再回来看这个，你会觉得有点意思，甚至可以加深你对语言能力的认知。下面我们对这些关键术语逐一进行解释。 简单性Java基本上是C++的纯净版，没有指针，头文件等，结构等乱七八糟的功能。简单性的一方面是在说这种语言的语法简单，语言程序设计简单，容易上手。还有另外一个方面是小，Java的目标之一就是能开发在小型机器上独立运行的软件。Java的解释器也就40KB，加上一些必要的类库，类加载器，网络，多线程支持等，也大概在210KB左右。 面向对象简单来说，面向对象是一种程序设计方法，相对应的是面向过程设计。与面向过程程序设计不一样的是，面向对象重点在数据和接口。理解了这两个概念对以后的语言的理解有很大的帮助。面向过程在代码形式来说，重点在过程，数据是过程的副产物；面向对象引入对象的概念，把所有事物都封装成一个对象，对象里有属性和方法，属性是数据，方法是操作数据的过程。对于一些比较小规模的问题分解成过程的开发方式比较理想，但是对于规模比较大的问题，面向对象要更适应。比如一个web服务器，使用面向过程来实现大概需要2000个过程，面向对象大概需要100个类，每个类有10个方法。出现问题的时候定位不同对象的数据项明显要比排查2000个过程要容易的多。 网络技能Java有一个拓展的例程库，用于处理HTTP和FTP之类的TCP/IP协议。这个库对针对操作sokect连接这种繁琐的操作进行了封装，使得Java应用程序可以通过URL打开和访问网络上的资源文件，就像访问本地文件一样方便。 健壮性Java设计的目标之一是使Java编写的程序有多方面的可靠性。表现在下面几个方面： 1.Java采用的指针模型可以消除重写内存和损坏数据的可能性。 2.Java投入大量的精力放在早期的问题检测，也就是程序编译阶段。Java的编译器可以检测到很多其他语言在运行时才能检测出来的问题。 安全性Java适用于网络和分布式环境，要达到这个目的，Java在安全性上做了很大的工作，体现在以下几个方面 1.防范运行时内存溢出 2.防范在自己的处理空间之外破坏内存 3.防范未经授权读写文件 之后的版本迭代更新也不断加入新的安全技术。 体系结构中立Java使用的是虚拟机技术，也就是编译器会将程序编译成一种跟计算机结构无关的文件格式，我们称之为字节码，当需要程序运行的时候，虚拟机的解释器可以快速的将这些字节码解释成对应的不同机器对应的机器指令执行。这并不是很独创的技术，很多语言都有这种设计。因为字节码需要虚拟机解释成机器指令然后执行，中间多了一步解释的过程，早期的解释器设计会让人产生一种误解，Java运行很慢，比不上c这种全速执行机器指令的程序，但是这已经是老皇历了，现在的Java解释器可以将使用最频繁的字节码序列翻译成机器指令，这叫做即时编译。所以现在的虚拟机执行字节码的速度比大家印象中的还要快。 可移植性Java的设计的目标之一是跨平台，所有的不同都是通过虚拟机去实现一些本地方法，对于上层的都是完全一致的，这就对可移植性提供了很大的支持。同时，Java的基础类型都是固定长度，字符是Unicode格式存储的，这就消除了字节存储顺序的问题。 解释型Java是通过解释器来翻译字节码并执行的。 高性能现在的即时编译器的性能可以跟传统编译器性能一较高下，由于即时编译器包含更多的信息，从这一方面来说，即时编译器已经超越了传统的编译器。 多线程Java虚拟机通过底层方法来调用操作系统或者线程库进行多线程操作，对于开发，Java调用多线程的代码也很方便。 动态性Java是一种动态语言，他的动态性体现在程序运行的时候可以动态加载类，同时还提供了反射等一系列特性动态访问对象的方法和属性。","categories":[{"name":"Java语言程序设计","slug":"Java语言程序设计","permalink":"https://liusxg.github.io/categories/Java语言程序设计/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liusxg.github.io/tags/Java/"},{"name":"Java语言程序设计","slug":"Java语言程序设计","permalink":"https://liusxg.github.io/tags/Java语言程序设计/"}]},{"title":"Java语言程序设计-预留关键字","slug":"Java语言程序设计-预留关键字","date":"2018-10-16T09:10:20.000Z","updated":"2018-10-16T09:31:21.690Z","comments":true,"path":"2018/10/16/Java语言程序设计-预留关键字/","link":"","permalink":"https://liusxg.github.io/2018/10/16/Java语言程序设计-预留关键字/","excerpt":"","text":"Java一共预留了51个关键字，不同的关键字各自对应的含义如下，在编写代码的过程中，命名不得跟关键字冲突。关键字大概分为7类：访问修饰符，定义或者创建，基础类型，用于调试代码，流程控制，捕获异常，导包。还有两个关键字暂时没有用到。 访问修饰符，用于方法或者属性上123private：这个特性只有该类方法能访问protected：这个特性只有该类，及其子类以及同一个包中的其他类能访问public：这个特性所有类都能访问 定义类，方法，接口，属性；继承，实现，创建实例1234567891011121314151617abstract：抽象类或方法class：定义一个类类型extends：继承final：一个常量，不能覆盖的类或者方法，不能派生子类implements：实现接口方法interface：定义一个接口类型native：本地方法new：创建一个实例null：一个空引用，技术上来说，这是一个直接量，不是关键字static：修饰的属性或者方法属于类不属于实例strictfp：对浮点运算使用严格的规则super：父类对象的引用或者父类构造方法synchronized：表示方法或者代码块同步执行this：当前实例对象的引用或者构造方法transient：标志非永久数据，声明不用序列话的成员域void：表示一个方法可以没有返回值volatile：确保一个字段能被多个线程访问 调试代码1assert：断言，用来查找程序内部错误 基础类型123456789boolean：布尔类型byte：8位整数类型char：Unicode字符类型double：双精度浮点类型enum：枚举类型float：单精度浮点类型int：32位整数类型long：64位整数类型short：16位整数类型 流程控制，条件判断123456789101112break：中断程序case：switch的一个分支continue：回到当前块的开始处default：switch的缺省分支do：do/while最前面的语句if：条件判断语句，后面带判断条件else：条件判断语句，if条件的字句for：一种循环结构instanceOf：判断一个对象是否为某一个类的实例return：方法的返回结果switch：条件判断语句：可以匹配多种结果while：条件判断语句，可以单独使用，也可以跟do配合使用 捕捉异常12345catch：捕获异常语句，try的子句finally：try的字句，表示最后总会执行的代码块throw：抛出一个异常throws：一个方法可能抛出的异常try：捕获异常语句 导包12import：导入一个包或者一个类package：包含类的包 保留字，预留的关键字，目前Java尚未使用到的关键字12const：未使用goto：未使用","categories":[{"name":"Java语言程序设计","slug":"Java语言程序设计","permalink":"https://liusxg.github.io/categories/Java语言程序设计/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://liusxg.github.io/tags/Java/"},{"name":"Java语言程序设计","slug":"Java语言程序设计","permalink":"https://liusxg.github.io/tags/Java语言程序设计/"}]},{"title":"VUE入坑指南","slug":"VUE入坑指南","date":"2018-10-12T07:31:05.000Z","updated":"2018-10-12T08:51:27.295Z","comments":true,"path":"2018/10/12/VUE入坑指南/","link":"","permalink":"https://liusxg.github.io/2018/10/12/VUE入坑指南/","excerpt":"","text":"安装环境先安装node.js，1brew install nodejs 然后npm替换成淘宝的镜像站 1npm install -g cnpm --registry=https://registry.npm.taobao.org 这样以后就能使用cnpm命令安安装包了 安装webpackwebpack 是个前端打包工具，详情google 1cnpm install webpack -g -g是全局的意思 安装vue脚手架vue-clivue-cli是vue官方发布的一个快速搭建项目的工具 1npm install vue-cli -g 创建示例项目创建项目先创建project workspace， 如果不创建也没关系 123mkdir VueProjectcd VueProject vue init webpack-simple 工程名字（不能使用中文） 操作如下图： 然后根据提示去操作，这个地方如果使用的是 cnpm命令的话，两个指令要同时都适用cnpm否则会缺少包 12345cd test npm install npm run dev 启动项目其实上面的npm run dev就是启动项目的 遇到的问题npm run dev在启动项目之后，访问 http://localhost:8080 的时候发现是一片空白 用浏览器调试显示如下： 解决办法： 12345devtool: &apos;#eval-source-map’ 改成devtool: &apos;inline-source-map’ 相关链接https://cn.vuejs.org/v2/guide/ https://webpack.docschina.org/configuration/devtool/","categories":[{"name":"前端","slug":"前端","permalink":"https://liusxg.github.io/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://liusxg.github.io/tags/前端/"},{"name":"VUE","slug":"VUE","permalink":"https://liusxg.github.io/tags/VUE/"}]},{"title":"算法导论-插入排序（Insertion Sort）","slug":"算法导论-插入排序（Insertion Sort）","date":"2018-10-11T06:50:00.000Z","updated":"2018-10-12T06:57:20.410Z","comments":true,"path":"2018/10/11/算法导论-插入排序（Insertion Sort）/","link":"","permalink":"https://liusxg.github.io/2018/10/11/算法导论-插入排序（Insertion Sort）/","excerpt":"","text":"题目输入 ：n个数的一个序列(a1, a2, … , an) 输出：输入序列的一个排序(a’1, a’2, … , a’n)，满足 a’1 &lt;= a’2 &lt;= … &lt;= a’n 插入排序算法描述插入排序的工作原理是： 通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。 在生活中，最直观插入排序的例子是，整理纸牌。人们在整理纸牌的方法是一张一张的来，通过对比手上已经排好顺序的排列，插入到适合的位置。 插入排序在实现上也是一种in-place排序列（这种排序概念请查看相应的文章），就是原地排序。所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。 Java实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.liusxg.sort;import java.util.Arrays;import java.util.List;*/*** * Created by liusxg on 2018/10/8. *** *** 插入排序 *** *** 工作原理是通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。 ** 插入排序在实现上也是一种in-place*排序（这种排序概念请查看相应的文章），就是原地排序。 *** 所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。 */public class InsertionSort &#123; protected static void sort(List&lt;Integer&gt; list) &#123; for (int i = 1; i &lt; list.size(); i++) &#123; //1 Integer key = list.get(i); //从后往前扫描，并且如果还没找到合适的位置，需要将已经排序的元素往后逐步挪动，给新的元素让出插入空间 int j = i - 1; for (; j &gt;= 0 &amp;&amp; list.get(j) &gt; key; j--) &#123; //2 list.set(j + 1, list.get(j)); System.out.println(\"compare to [0, \" + j + \"] : \" + list); &#125; list.set(j + 1, key); System.out.println(\"current list : \" + list); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; testArr = Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1);// List&lt;Integer&gt; testArr = Arrays.asList(3, 1); System.out.println(\"before sort: \" + testArr); InsertionSort.sort(testArr); System.out.println(\"after sort: \" + testArr); &#125;&#125; 算法复杂度分析根据 算法分析 所描述的，当插入排序的输入序列是正序的时候，插入排序的算法运行时间是是一个n的线性函数，即算法复杂度为⍬(n)；当输入序列是倒序的时候，算法运行时间是n的二次函数，即算法复杂度为 ⍬(n^2)。","categories":[{"name":"算法","slug":"算法","permalink":"https://liusxg.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://liusxg.github.io/tags/算法/"}]},{"title":"算法导论-算法分析","slug":"算法导论-算法分析","date":"2018-10-10T09:21:28.000Z","updated":"2019-03-20T03:20:06.906Z","comments":true,"path":"2018/10/10/算法导论-算法分析/","link":"","permalink":"https://liusxg.github.io/2018/10/10/算法导论-算法分析/","excerpt":"","text":"怎么样衡量一个算法的性能？​ 分析一个算法，其实意味着要去预测这个算法需要的资源。虽然我们有时主要关心内存，通信带宽或者计算机硬件这类资源，但是我们通常最关心的是该算法的计算时间。可以说一个算法的计算时间是衡量一个算法是否优质的最重要的一个指标。执行越快的算法我们可以称之为越有效。算法分析主要针对是多个算法进行对比，对于单个算法毫无意义。这个执行时间通常被称为时间复杂度。通过分析对比多个算法的时间复杂度，我们可以选择出最有效的算法，同时在这个分析的前提是这个算法是正确的，经得起循环不变式检验的。 分析过程通过分析插入排序算法，我们来理解怎么进行一个算法分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*** * Created by liusxg on 2018/10/8. *** *** 插入排序 *** *** 工作原理是通过构建有序序列，对于未排序的序列，在已排序的序列从后往前扫描，找到相应位置插入。 ** 插入排序在实现上也是一种in-place*排序（这种排序概念请查看相应的文章），就是原地排序。 *** 所以在排序对比过程中，需要不断的将已经排序的元素往后逐步挪动，给新的元素腾出插入空间。 */public class InsertionSort &#123; protected static void sort(List&lt;Integer&gt; list) &#123; for (int i = 1; i &lt; list.size(); i++) &#123; //1 Integer key = list.get(i); //2 //从后往前扫描，并且如果还没找到合适的位置，需要将已经排序的元素往后逐步挪动，给新的元素让出插入空间 int j = i - 1; //3 for (; j &gt;= 0 &amp;&amp; list.get(j) &gt; key; j--) &#123; //4 list.set(j + 1, list.get(j)); //5 System.out.println(\"compare to [0, \" + j + \"] : \" + list); &#125; list.set(j + 1, key); //6 System.out.println(\"current list : \" + list); &#125; &#125; public static void main(String[] args) &#123; List&lt;Integer&gt; testArr = Arrays.asList(9, 8, 7, 6, 5, 4, 3, 2, 1); System.out.println(\"before sort: \" + testArr); InsertionSort.sort(testArr); System.out.println(\"after sort: \" + testArr); &#125;&#125; 先贴出插入排序的代码； 因为不知道不同计算机影响对单句代码执行优化的程度，而且不同的语句执行的时间也不一定一样，但是相同的一行代码重复执行基本上是一个常量时间。以上插入排序的代码一共有6行，我们暂定c1~c6分别代表着6行代码各自的执行时间。 假设需要排序的序列长度是n，即n=list.size()，我们可以得到每一行代码执行的总时间，即各自的执行次数*执行时间； 第一行根据循环次数，会执行n-1次，总执行时间是 t1=c1\\*(n-1) 然后就是t2=c2\\*(n-1)t3=c3\\*(n-1)t4看情况，如果序列已经是正序了那就是 c4\\*(n-1)，如果是倒序，则是 c4\\*(1+2+…+n-1)=(1/2)\\*c4*n\\*(n-1)t5在t4的作用域里，如果序列已经是正序了那就是 0，如果是倒序，则是 c5\\*(1+2+…+n-1)=(1/2)\\*c5*n\\*(n-1)这时候就可以计算出算法的最优时间和最坏时间 总执行时间：T=t1+t2+t3+t4+t5+t6 最优时间T优=(c1+c2+c3+c4+c5+c6)\\*(n-1)=(c1+c2+c3+c4+c5+c6)\\*n - (c1+c2+c3+c4+c5+c6) 最坏时间T坏=(c4/2+c5/2)\\*n\\*(n-1) + (c1+c2+c3+c6)\\*(n-1) 化简：T坏=(c4/2+c5/2)\\*n^2 + (c1+c2+c3+c6-c4/2-c5/2)\\*n - (c1+c2+c3+c6)最优时间是一个n的线性函数，最坏时间是n的二次函数。 为什么要求一个算法的最坏时间？1.最坏时间代表着这个算法执行时间的上界，意味着不管输入是怎么样的，执行时间都不会超过这个最坏时间； 2.算法的最坏情况经常会出现，不能寄希望于偶尔会出现最好的情况。 3.算法的平均情况一般会跟最坏的情况是一致的。 所以一般来说，算法的最坏情况更能体现一个算法的有效性，更具有参考价值。 增长量级​ 因为上面我们并不知晓某一行代码在不同的计算机硬件具体的执行时间，我们就已经简化假设了单行代码的执行时间为常量，c1~c6，虽然已经简化了，但是明显影响我们对这个算法的分析。插入排序算法最坏时间的结果是(c4/2+c5/2)n^2 + (c1+c2+c3+c6-c4/2-c5/2)n - (c1+c2+c3+c6)，看起来还是不是很直观。我们还可以继续简化，令 a=(c4/2+c5/2), b=(c1+c2+c3+c6-c4/2-c5/2), c=- (c1+c2+c3+c6)，所以得到的是 ，其中a,b,c也是常量。我们注意到这样并不会影响结果，而且更加的直观。 ​ 现在我们要更简化上面的式子，其实我们真正感兴趣的是执行时间的增长率，增长量级。所以我们比较关注的是a^2这一项，当n足够大的时候，就可以省略低阶，和常系数。忽略了这些之后，留下的只剩下最重要的因子n^2。这时候我们引入一个表达式，⍬(n^2)，读作theta n^2。这就是很多文章里写的时间复杂度。 结论​ 如果一个算法的最差运行时间要比另外一个算法最差运行时间具有更小的增长量级，我们通常认为这个算法比另外一个算法更有效。","categories":[{"name":"算法","slug":"算法","permalink":"https://liusxg.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://liusxg.github.io/tags/算法/"}]}]}